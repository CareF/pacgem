#!/usr/bin/ruby

require 'tmpdir'
require 'rubygems'
require 'rubygems/format'
require 'shellwords'
require 'open-uri'
require 'digest/sha2'
require 'optparse'
require 'fileutils'

module Pacgem
  module Util
    def which?(name)
      `which #{name} 2>/dev/null`
      $?.success?
    end

    def spew(file, content)
      File.open(file, 'w') {|f| f.write(content) }
    end

    COLORS = {
      clear:         0,
      bold:          1,
      dark:          2,
      italic:        3, # not widely implemented
      underline:     4,
      blink:         5,
      rapid_blink:   6, # not widely implemented
      reverse:       7,
      concealed:     8,
      strikethrough: 9, # not widely implemented
      black:         30,
      red:           31,
      green:         32,
      yellow:        33,
      blue:          34,
      magenta:       35,
      cyan:          36,
      white:         37,
      bg_black:      40,
      bg_red:        41,
      bg_green:      42,
      bg_yellow:     43,
      bg_blue:       44,
      bg_magenta:    45,
      bg_cyan:       46,
      bg_white:      47,
    }

    def color(s, *c)
      if STDOUT.isatty
        c.inject('') {|x,c| "#{x}\e[#{COLORS[c]}m" } + "#{s}\e[0m"
      else
        s
      end
    end

    def info(s)
      puts(color('==> ', :green, :bold) + color(s, :bold))
    end

    def warn(s)
      puts(color('==> WARNING: ', :yellow, :bold) + color(s, :bold))
    end

    def error(s)
      puts(color('==> ERROR: ', :red, :bold) + color(s, :bold))
    end

    def alert(s)
      puts(color('==> ', :red, :bold, :blink) + color(s, :bold))
    end

    def subinfo(s)
      puts(color('  -> ', :blue, :bold) + color(s, :bold))
    end

    extend self
  end

  class Package
    include Util

    def initialize(name, version, uri, explicit)
      @gemname = name
      @name = "ruby-#{name.downcase}"
      @version, @uri, @explicit = version, uri, explicit
    end

    def install(noinstall = false)
      Dir.mkdir(@name)
      Dir.chdir(@name) do
        download
        gen_pkgbuild
        makepkg(noinstall)
        unless noinstall
          namcap
          pacman_install
        end
      end
    end

    def installed?
      installed = `pacman -Q #{@name.shellescape} 2>/dev/null`.split(/\s+/)
      installed[1] =~ /^#{@version}\-\d+$/
    end

    private

    def download
      @gemfile = "#{@gemname}-#{@version}.gem"
      open("#{@uri}gems/#{@gemfile}") do |i|
        File.open(@gemfile, 'w') do |o|
          while buf = i.read(0xFFFF)
            o.write(buf)
          end
        end
      end
    end

    def makepkg(nodeps)
      `makepkg #{nodeps && '--nodeps'}`
      @pkgfile = Dir["#{@name}-*.pkg.*"].first
      raise "makepkg #{@name} failed" unless @pkgfile
    end

    def namcap
      if which?('namcap')
        info "Checking #{@pkgfile} with namcap..."
        `namcap #{@pkgfile}`.each_line do |line|
          subinfo(line.chomp)
        end
      else
        warn "namcap is not installed"
      end
    end

    def pacman_install
      alert "Installing #{@pkgfile} with pacman..."
      `sudo pacman --as#{@explicit ? 'explicit' : 'deps'} -U #{@pkgfile.shellescape}`
    end

    def gen_pkgbuild
      spec = Gem::Format.from_file_by_path(@gemfile).spec

      depends = %w(ruby)
      spec.runtime_dependencies.each do |dep|
        dep.requirement.requirements.each do |comp, ver|
          comp = '>=' if comp == '~>'
          depends << "ruby-#{dep.name}#{comp}#{ver}"
        end
      end

      digest = Digest::SHA2.file(@gemfile).to_s
      license = spec.license || 'Ruby'
      arch = spec.extensions.empty? ? %w(any) : %w(i686 x86_64)

      pkgbuild = %{# Generated by pacgem
_gemname=#{spec.name}
pkgname=ruby-$_gemname
pkgver=#{spec.version}
pkgrel=1
pkgdesc=#{spec.summary.inspect}
arch=(#{arch.map(&:inspect).join(' ')})
url=#{spec.homepage.inspect}
license=(#{license.inspect})
depends=(#{depends.map(&:inspect).join(' ')})
makedepends=('rubygems')
source=(#{@uri}gems/$_gemname-$pkgver.gem)
sha256sums=(#{digest})
noextract=($_gemname-$pkgver.gem)
build() {
  cd $srcdir
  # _gemdir is defined inside build() because if ruby[gems] is not installed on the system
  #  makepkg will barf when sourcing the PKGBUILD
  local _gemdir=`gem environment gemdir`
  gem install --no-ri --no-rdoc --ignore-dependencies -n "$pkgdir/usr/bin" -i "$pkgdir$_gemdir" $_gemname-$pkgver.gem
  [ -d "$pkgdir$_gemdir/bin" ]  && find "$pkgdir$_gemdir/bin" -type f -exec chmod 755 '{}' ';'
  [ -d "$pkgdir$_gemdir/gems" ] && find "$pkgdir$_gemdir/gems" -name '*.o' -exec rm -f '{}' ';'
  rm -f "$pkgdir$_gemdir/cache/$_gemname-$pkgver.gem"
  find "$pkgdir$_gemdir" -depth -type d -empty -exec rmdir '{}' ';'
}
}
      spew('PKGBUILD', pkgbuild)
    end
  end

  class Installer
    include Util

    def initialize(options)
      @options = options
      @order = []
      @packages = {}
    end

    def install
      @order.reject! {|pkg| pkg.installed? }
      @order.each {|pkg| pkg.install(@options[:noinstall]) }
    end

    def resolve(name, version = nil)
      resolve_dep(Gem::Dependency.new(name, version), true)
    end

    private

    def resolve_dep(dep, explicit)
      @packages[dep.name] ||= begin
        info "Resolving Gem #{dep}..."
        spec, uri = Gem::SpecFetcher.fetcher.fetch(dep, true).last
        raise "Gem #{dep} not found" unless spec
        subinfo("#{spec.full_name}: #{spec.summary}")
        spec.runtime_dependencies.each {|dep| resolve_dep(dep, false) }
        Package.new(dep.name, spec.version, uri, explicit).tap {|pkg| @order << pkg }
      end
    end
  end

  class Command
    include Util

    def initialize(args)
      @args = args
      @options = {}
    end

    def run
      @opts = OptionParser.new(&method(:set_opts))
      @opts.parse!(@args)
      process
      exit 0
    rescue Exception => ex
      raise ex if @options[:trace] || SystemExit === ex
      error ex.message
      subinfo 'Use --trace for backtrace.'
      exit 1
    end

    private

    def process
      if @args.length < 1
        puts @opts
        exit
      end

      raise 'You must not be root to run pacgem!' if Process.uid == 0

      trap :SIGINT do
        Util.error 'Aborted by user! Exiting...'
        exit
      end

      if @options[:destdir]
        dir = File.expand_path(@options[:destdir])
        FileUtils.mkpath(dir)
        info "Saving package files in #{dir}"
      else
        dir = Dir.mktmpdir('pacgem-')
      end

      begin
        Dir.chdir(dir) do
          installer = Installer.new(@options)
          @args.each do |gem|
            if gem =~ /^([-\w]+)((?:[<>]=?|=|~>|-)\d+(?:\.\d+)*)?$/
              name, version = $1, $2
              installer.resolve(name, version =~ /^-/ ? version[1..-1] : version)
            else
              installer.resolve(gem)
            end
          end
          installer.install
        end
      ensure
        FileUtils.remove_entry_secure(dir) unless @options[:destdir]
      end
    end

    def set_opts(opts)
      opts.banner = 'Usage: pacgem [options] gems...'

      opts.separator %q{
Pacgem installs Ruby Gems using the Arch Linux Package Manager (pacman).

Examples:
    pacgem --noinstall rack    Create ruby-rack package in the directory ./ruby-rack
    pacgem rack-1.0            Create temporary ruby-rack package and install it
    pacgem 'rack>1.0'          Different version specification
    pacgem thin 'rack~>1.0'    Different version specification

Options:
}

      opts.on('-d DIR', '--destdir DIR', String, 'Destination directory for package files') do |dir|
        @options[:destdir] = dir
      end

      opts.on('-n', '--noinstall', :NONE, 'Do not install package files') do
        @options[:noinstall] = true
        @options[:destdir] = Dir.pwd
      end

      opts.on('--trace', :NONE, 'Show a full traceback on error') do
        @options[:trace] = true
      end

      opts.on_tail('-h', '--help', 'Show this message') do
        puts opts
        exit
      end
    end
  end
end

Pacgem::Command.new(ARGV).run if $0 == __FILE__
