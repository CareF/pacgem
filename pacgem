#!/usr/bin/ruby

require 'tmpdir'
require 'rubygems'
require 'rubygems/format'
require 'shellwords'
require 'open-uri'
require 'digest/sha2'
require 'optparse'
require 'fileutils'

module Pacgem
  module Util
    def which?(name)
      `which #{name} 2>/dev/null`
      $?.success?
    end

    def spew(file, content)
      File.open(file, 'w') {|f| f.write(content) }
    end

    def truncate(s, max, omission = '...')
      s = s.to_s
      s.length > max ? s[0...max] + omission : s
    end

    COLORS = {
      :clear         =>  0,
      :bold          =>  1,
      :dark          =>  2,
      :italic        =>  3, # not widely implemented
      :underline     =>  4,
      :blink         =>  5,
      :rapid_blink   =>  6, # not widely implemented
      :reverse       =>  7,
      :concealed     =>  8,
      :strikethrough =>  9, # not widely implemented
      :black         => 30,
      :red           => 31,
      :green         => 32,
      :yellow        => 33,
      :blue          => 34,
      :magenta       => 35,
      :cyan          => 36,
      :white         => 37,
      :bg_black      => 40,
      :bg_red        => 41,
      :bg_green      => 42,
      :bg_yellow     => 43,
      :bg_blue       => 44,
      :bg_magenta    => 45,
      :bg_cyan       => 46,
      :bg_white      => 47,
    }

    def color(s, *c)
      if STDOUT.isatty
        c.inject('') {|x,c| "#{x}\e[#{COLORS[c]}m" } + "#{s}\e[0m"
      else
        s
      end
    end

    def info(s)
      puts(color('==> ', :green, :bold) + color(s, :bold))
    end

    def warn(s)
      puts(color('==> WARNING: ', :yellow, :bold) + color(s, :bold))
    end

    def error(s)
      puts(color('==> ERROR: ', :red, :bold) + color(s, :bold))
    end

    def alert(s)
      puts(color('==> ', :red, :bold, :blink) + color(s, :bold))
    end

    def subinfo(s)
      puts(color('  -> ', :blue, :bold) + color(s, :bold))
    end

    extend self
  end

  class Pkgbuild
    def initialize
      @vars = []
      @@build ||= DATA.read
    end

    def []=(key, val)
      @vars << [key, val]
    end

    def to_s
      lines = "# Generated by pacgem\n"
      @vars.each do |(key,val)|
        if Array === val
          val = val.map {|v| v.inspect }.join("\n" + (' ' * (key.size + 2)))
          lines << "#{key}=(#{val})\n"
        else
          lines << "#{key}=#{val.inspect}\n"
        end
      end
      lines + @@build
    end
  end

  class Package
    include Util

    def initialize(name, version, uri, explicit)
      @gemname = name
      @name = "ruby-#{name.downcase}"
      @version, @uri, @explicit = version, uri, explicit
    end

    def install(options)
      FileUtils.mkpath(@name)
      Dir.chdir(@name) do
        download
        gen_pkgbuild(options)
        makepkg(options[:noinstall])
        namcap
        pacman_install unless options[:noinstall]
      end
    end

    def installed?
      installed = `pacman -Q #{@name.shellescape} 2>/dev/null`.split(/\s+/)
      installed[1] =~ /^#{@version}\-\d+$/
    end

    private

    def download
      @gemfile = "#{@gemname}-#{@version}.gem"
      FileUtils.copy_stream(open("#{@uri}gems/#{@gemfile}"), File.open(@gemfile, 'w'))
    end

    def makepkg(nodeps)
      system("makepkg -f #{nodeps && '--nodeps'}")
      @pkgfile = Dir["#{@name}-*.pkg.*"].first
      raise "makepkg #{@name} failed" unless @pkgfile
    end

    def namcap
      if which?('namcap')
        info "Checking #{@pkgfile} with namcap..."
        system("namcap #{@pkgfile}")
      else
        warn "namcap is not installed"
      end
    end

    def pacman_install
      alert "Installing #{@pkgfile} with pacman..."
      system("sudo pacman --as#{@explicit ? 'explicit' : 'deps'} -U #{@pkgfile.shellescape}")
    end

    def gen_pkgbuild(options)
      spec = Gem::Format.from_file_by_path(@gemfile).spec

      depends = %w(ruby)
      spec.runtime_dependencies.each do |dep|
        dep.requirement.requirements.each do |comp, ver|
          comp = '>=' if comp == '~>'
          depends << "ruby-#{dep.name.downcase}#{comp}#{ver}"
        end
      end

      optdepends = []
      spec.development_dependencies.each do |dep|
        optspec, opturi = Gem::SpecFetcher.fetcher.fetch(dep, true).last
        optdepends << "ruby-#{dep.name.downcase}: #{truncate(optspec.summary, 80)}" if optspec
      end

      builder = %w(build fix)
      unless spec.extensions.empty?
        builder << 'cleanext'
        builder << 'autodepends' unless options[:noautodepends]
      end

      pkg = Pkgbuild.new
      pkg['_gemname']    = spec.name
      pkg['_gembuilder'] = builder
      pkg['pkgname']     = @name
      pkg['pkgver']      = spec.version.to_s
      pkg['pkgrel']      = 1
      pkg['pkgdesc']     = spec.summary
      pkg['arch']        = spec.extensions.empty? ? %w(any) : %w(i686 x86_64)
      pkg['url']         = spec.homepage
      pkg['license']     = [spec.license || 'Ruby']
      pkg['makedepends'] = %w(rubygems binutils sed findutils)
      pkg['depends']     = depends
      pkg['optdepends']  = optdepends
      pkg['source']      = ["#{@uri}gems/$_gemname-$pkgver.gem"]
      pkg['sha256sums']  = [Digest::SHA2.file(@gemfile).to_s]
      pkg['noextract']   = %w($_gemname-$pkgver.gem)
      pkg['options']     = %w(!emptydirs)
      spew('PKGBUILD', pkg.to_s)
    end
  end

  class Installer
    include Util

    def initialize(options)
      @options = options
      @order = []
      @packages = {}
    end

    def install
      @order.reject! {|pkg| pkg.installed? }
      @order.each {|pkg| pkg.install(@options) }
    end

    def resolve(name, version = nil)
      resolve_dep(Gem::Dependency.new(name, version), true)
    end

    private

    def resolve_dep(dep, explicit)
      @packages[dep.name] ||= begin
        spec, uri = Gem::SpecFetcher.fetcher.fetch(dep, true).last
        raise "Gem #{dep} not found" unless spec
        subinfo("#{spec.full_name}: #{spec.summary}")
        spec.runtime_dependencies.each {|dep| resolve_dep(dep, false) }
        (@order << Package.new(dep.name, spec.version, uri, explicit)).last
      end
    end
  end

  class Command
    include Util

    def initialize(args)
      @args = args
      @options = {}
    end

    def run
      @opts = OptionParser.new(&method(:set_opts))
      @opts.parse!(@args)
      process
      exit 0
    rescue Exception => ex
      raise ex if @options[:trace] || SystemExit === ex
      error ex.message
      subinfo 'Use --trace for backtrace.'
      exit 1
    end

    private

    def process
      if @args.length < 1
        puts @opts
        exit
      end

      raise 'You must not be root to run pacgem!' if Process.uid == 0

      trap :SIGINT do
        Util.error 'Aborted by user! Exiting...'
        exit
      end

      if @options[:destdir]
        dir = File.expand_path(@options[:destdir])
        FileUtils.mkpath(dir)
        info "Saving package files in #{dir}"
      else
        dir = Dir.mktmpdir('pacgem-')
      end

      begin
        Dir.chdir(dir) do
          installer = Installer.new(@options)
          info 'Resolving gems...'
          @args.each do |gem|
            if gem =~ /^([-\w]+)((?:[<>]=?|=|~>|-)\d+(?:\.\d+)*)?$/
              name, version = $1, $2
              installer.resolve(name, version =~ /^-/ ? version[1..-1] : version)
            else
              installer.resolve(gem)
            end
          end
          installer.install
        end
      ensure
        FileUtils.remove_entry_secure(dir) unless @options[:destdir]
      end
    end

    def set_opts(opts)
      opts.banner = 'Usage: pacgem [options] gems...'

      opts.separator %q{
Pacgem installs Ruby Gems using the Arch Linux Package Manager (pacman).

Examples:
    pacgem --noinstall rake    Create ruby-rake package in the directory ./ruby-rake
    pacgem rake-1.0            Create temporary ruby-rake package and install it
    pacgem 'rake>1.0'          Different version specification
    pacgem thin 'rake~>1.0'    Different version specification

Options:
}

      opts.on('-d DIR', '--destdir DIR', String, 'Destination directory for package files') do |dir|
        @options[:destdir] = dir
      end

      opts.on('-n', '--noinstall', :NONE, 'Do not install package files') do
        @options[:noinstall] = true
        @options[:destdir] = Dir.pwd
      end

      opts.on('--noautodepends', :NONE, 'Disable automatic dependency generation for shared objects (*.so)') do
        @options[:noautodepends] = true
      end

      opts.on('--trace', :NONE, 'Show a full traceback on error') do
        @options[:trace] = true
      end

      opts.on_tail('-h', '--help', 'Show this message') do
        puts opts
        exit
      end
    end
  end
end

Pacgem::Command.new(ARGV).run if $0 == __FILE__

__END__

_gem_build() {
  local gemdir=$1

  msg 'Installing gem...'

  # Install the gem
  gem install --no-ri --no-rdoc --ignore-dependencies -n "$pkgdir/usr/bin" -i "$gemdir" "$srcdir/$_gemname-$pkgver.gem"
}

_gem_fix() {
  local gemdir=$1

  msg 'Fixing gem installation...'

  # Set mode of executables to 755
  [ -d "$gemdir/bin" ] && find "$gemdir/bin" -type f -exec chmod 755 '{}' ';'

  # Find man pages and move them to usr/share
  local mandir="$gemdir/gems/$_gemname-$pkgver/man"
  if [ -d "$mandir" ]; then
    mkdir -p "$pkgdir/usr/share"
    mv "$mandir" "$pkgdir/usr/share"
  fi

  # Remove cached gem file
  rm -f "$gemdir/cache/$_gemname-$pkgver.gem"

  # Sometimes there are files which are not world readable. Fix this.
  find "$pkgdir" -type f '!' -perm '-004' -exec chmod o+r '{}' ';'
}

_gem_cleanext() {
  local gemdir=$1

  msg 'Removing native build leftovers...'
  local extdir="$gemdir/gems/$_gemname-$pkgver/ext"
  [ -d "$extdir" ] && find "$extdir" '(' -name '*.o' -or -name '*.so' ')' -exec rm -f '{}' ';'
}

# Check if list includes element
_includes_not() {
  local elem=$1
  shift
  for i; do [ "$i" = "$elem" ] && return 1; done
  return 0
}

# Check if dependency is already satisfied
_dependency_satisfied() {
  local dep=$1 deps="${depends[@]}"
  while true; do
    _includes_not $dep ${deps[@]} || return 0
    local found=0 pkg
    # Warning: This could break easily if the pacman output format changes.
    for pkg in $(pacman -Qi ${deps[@]} 2>/dev/null | sed '/Depends/!d;s/.*: //;s/None\|>=[^ ]*//g'); do
      _includes_not $pkg ${deps[@]} && deps=(${deps[@]} $pkg) && found=1
    done
    [ $found -eq 1 ] || break
  done
  return 1
}

_gem_autodepends() {
  msg 'Automatic dependency resolution...'

  # Find all referenced shared libraries
  local deps=$(find "$pkgdir" -type f -name '*.so')
  [ "$deps" != '' ] || return 0

  deps=$(readelf -d $deps | sed '/library:/!d;s/.*library: \[\(.*\)\].*/\1/')

  # Find referenced libraries on the library search path
  local libs=() lib path
  for lib in $deps; do
    for path in /lib /usr/lib; do
      [ -f "$path/$lib" ] && libs=(${libs[@]} "$path/$lib")
    done
  done
  [ "${#libs}" -ne 0 ] || return 0

  msg2 "Referenced libraries: ${libs[*]}"

  # Find matching packages with pacman -Qo
  # and add them to the depends array
  local pkg
  for pkg in $(pacman -Qqo ${libs[@]}); do
    _dependency_satisfied $pkg || depends=(${depends[@]} $pkg)
  done
  msg2 "Referenced packages: ${depends[*]}"
}

build() {
  # gemdir is defined inside build() because if ruby[gems] is not installed on the system
  # makepkg will barf when sourcing the PKGBUILD
  local gemdir="$pkgdir$(gem environment gemdir)"

  local i
  for i in ${_gembuilder[@]}; do _gem_$i "$gemdir"; done
}
