#!/usr/bin/ruby

require 'tmpdir'
require 'rubygems'
require 'rubygems/format'
require 'shellwords'
require 'open-uri'
require 'digest/sha2'

def download_spec(name, version)
  puts "Download #{name} gem specification"
  version ||= Gem::Requirement.default
  spec = Gem::SpecFetcher.fetcher.fetch(Gem::Dependency.new(name, version), true).last
  raise "Could not find #{name} in any repository" if !spec
  spec
end

def get_depends(spec)
  depends = []
  spec.runtime_dependencies.each do |dep|
    dep.requirement.requirements.each do |comp, ver|
      depends << [dep.name, "#{comp}#{ver}"]
    end
  end
  depends
end

def generate_pkgbuild(spec, depends)
  depends = %w(ruby) + depends.map do |name,version|
    version.sub!(/^~>/, '>=')
    "ruby-#{name}#{version}"
  end

  name = spec.name
  license = spec.license || 'Ruby'
  digest = Digest::SHA2.file("#{spec.full_name}.gem").to_s
  arch = spec.extensions.empty? ? %w(any) : %w(i686 x86_64)

%{# Generated by pacgem
_gemname=#{spec.name}
pkgname=ruby-$_gemname
pkgver=#{spec.version}
pkgrel=1
pkgdesc=#{spec.summary.inspect}
arch=(#{arch.map(&:inspect).join(' ')})
url=#{spec.homepage.inspect}
license=(#{license.inspect})
depends=(#{depends.map(&:inspect).join(' ')})
makedepends=('rubygems')
source=(http://rubygems.org/gems/$_gemname-$pkgver.gem)
sha256sums=(#{digest})
noextract=($_gemname-$pkgver.gem)
build() {
  cd $srcdir
  # _gemdir is defined inside build() because if ruby[gems] is not installed on the system
  #  makepkg will barf when sourcing the PKGBUILD
  local _gemdir=`gem environment gemdir`
  gem install --no-ri --no-rdoc --ignore-dependencies -n "$pkgdir/usr/bin" -i "$pkgdir$_gemdir" $_gemname-$pkgver.gem
  [ -d "$pkgdir$_gemdir/bin" ]  && find "$pkgdir$_gemdir/bin" -type f -exec chmod 755 '{}' ';'
  [ -d "$pkgdir$_gemdir/gems" ] && find "$pkgdir$_gemdir/gems" -name '*.o' -exec rm -f '{}' ';'
  rm -f "$pkgdir$_gemdir/cache/$_gemname-$pkgver.gem"
  rmdir "$pkgdir$_gemdir/bin"   || true
  rmdir "$pkgdir$_gemdir/cache" || true
  rmdir "$pkgdir$_gemdir/doc"   || true
}
}
end

def which?(name)
  `which #{name}`
  $?.success?
end

def spew(file, content)
  File.open(file, 'w') {|f| f.write(content) }
end

def install_package(name, version, explicit = true)
  spec, uri = download_spec(name, version)
  name = "ruby-#{spec.name}"
  full_name = "ruby-#{spec.full_name}"

  installed = `pacman -Q #{name.shellescape} 2>/dev/null`.split(/\s+/)
  if installed[1] =~ /^#{spec.version}\-\d+$/
    puts "#{full_name} is already installed"
  else
    depends = get_depends(spec)
    depends.each {|n, v| install_package(n, v, false) }

    Dir.mkdir(name)

    gem_name = "#{spec.full_name}.gem"
    File.open(File.join(name, gem_name), 'w') do |f|
      IO.copy_stream(open("#{uri}gems/#{gem_name}"), f)
    end
    puts "Downloaded #{gem_name}"

    Dir.chdir(name) do
      spec = Gem::Format.from_file_by_path(gem_name).spec

      spew('PKGBUILD', generate_pkgbuild(spec, depends))
      `makepkg`
      pkgfile = Dir["#{full_name}-*.pkg.*"].first
      raise "makepkg #{full_name} failed" if !pkgfile
      if which?('namcap')
        puts "Checking #{pkgfile} with namcap"
        `namcap #{pkgfile} 1>&2`
      end
      puts "Installing #{pkgfile} with pacman"
      `sudo pacman #{explicit ? '--asexplicit' : '--asdeps'} -U #{pkgfile.shellescape}`
    end
  end
end

if $0 == __FILE__
  if ARGV.length < 1
    puts "Usage: #{$0} gem-name [gem-version]"
    exit
  end

  begin
    raise 'Must not be root' if Process.uid == 0

    Dir.mktmpdir('pacgem-') do |tmp|
      Dir.chdir(tmp) do
        install_package(ARGV[0], ARGV[1])
      end
    end
  rescue => ex
    puts ex.message
    exit 1
  end
end
