#!/usr/bin/ruby

require 'tmpdir'
require 'rubygems'
require 'rubygems/format'
require 'shellwords'
require 'open-uri'
require 'digest/sha2'

module PacGem
  module Util
    def which?(name)
      `which #{name} 2>/dev/null`
      $?.success?
    end

    def spew(file, content)
      File.open(file, 'w') {|f| f.write(content) }
    end

    COLORS = {
      clear:         0,
      bold:          1,
      dark:          2,
      italic:        3, # not widely implemented
      underline:     4,
      blink:         5,
      rapid_blink:   6, # not widely implemented
      reverse:       7,
      concealed:     8,
      strikethrough: 9, # not widely implemented
      black:         30,
      red:           31,
      green:         32,
      yellow:        33,
      blue:          34,
      magenta:       35,
      cyan:          36,
      white:         37,
      bg_black:      40,
      bg_red:        41,
      bg_green:      42,
      bg_yellow:     43,
      bg_blue:       44,
      bg_magenta:    45,
      bg_cyan:       46,
      bg_white:      47,
    }

    def color(s, *c)
      if STDOUT.isatty
        c.inject('') {|x,c| "#{x}\e[#{COLORS[c]}m" } + "#{s}\e[0m"
      else
        s
      end
    end

    def info(s)
      puts(color('==> ', :green, :bold) + color(s, :bold))
    end

    def warn(s)
      puts(color('==> WARNING: ', :yellow, :bold) + color(s, :bold))
    end

    def error(s)
      puts(color('==> ERROR: ', :red, :bold) + color(s, :bold))
    end

    def alert(s)
      puts(color('==> ', :red, :bold, :blink) + color(s, :bold))
    end

    def subinfo(s)
      puts(color('  -> ', :blue, :bold) + color(s, :bold))
    end

    extend self
  end

  class Package
    include Util

    def initialize(name, version, uri, explicit)
      @gemname = name
      @name = "ruby-#{name.downcase}"
      @version, @uri, @explicit = version, uri, explicit
    end

    def install
      Dir.mkdir(@name)
      Dir.chdir(@name) do
        download
        generate_pkgbuild
        build
        check
        system_install
      end
    end

    def installed?
      installed = `pacman -Q #{@name.shellescape} 2>/dev/null`.split(/\s+/)
      installed[1] =~ /^#{@version}\-\d+$/
    end

    private

    def download
      @gemfile = "#{@gemname}-#{@version}.gem"
      IO.copy_stream(open("#{@uri}gems/#{@gemfile}"), File.open(@gemfile, 'w'))
    end

    def build
      `makepkg`
      @pkgfile = Dir["#{@name}-*.pkg.*"].first
      raise "makepkg #{@name} failed" if !@pkgfile
    end

    def check
      if which?('namcap')
        info "Checking #{@pkgfile} with namcap..."
        `namcap #{@pkgfile}`.each_line do |line|
          subinfo(line.chomp)
        end
      else
        warn "namcap is not installed"
      end
    end

    def system_install
      alert "Installing #{@pkgfile} with pacman..."
      `sudo pacman --as#{@explicit ? 'explicit' : 'deps'} -U #{@pkgfile.shellescape}`
    end

    def generate_pkgbuild
      spec = Gem::Format.from_file_by_path(@gemfile).spec

      depends = %w(ruby)
      spec.runtime_dependencies.each do |dep|
        dep.requirement.requirements.each do |comp, ver|
          comp = '>=' if comp == '~>'
          depends << "ruby-#{dep.name}#{comp}#{ver}"
        end
      end

      digest = Digest::SHA2.file(@gemfile).to_s
      license = spec.license || 'Ruby'
      arch = spec.extensions.empty? ? %w(any) : %w(i686 x86_64)

      pkgbuild = %{# Generated by pacgem
_gemname=#{spec.name}
pkgname=ruby-$_gemname
pkgver=#{spec.version}
pkgrel=1
pkgdesc=#{spec.summary.inspect}
arch=(#{arch.map(&:inspect).join(' ')})
url=#{spec.homepage.inspect}
license=(#{license.inspect})
depends=(#{depends.map(&:inspect).join(' ')})
makedepends=('rubygems')
source=(#{@uri}gems/$_gemname-$pkgver.gem)
sha256sums=(#{digest})
noextract=($_gemname-$pkgver.gem)
build() {
  cd $srcdir
  # _gemdir is defined inside build() because if ruby[gems] is not installed on the system
  #  makepkg will barf when sourcing the PKGBUILD
  local _gemdir=`gem environment gemdir`
  gem install --no-ri --no-rdoc --ignore-dependencies -n "$pkgdir/usr/bin" -i "$pkgdir$_gemdir" $_gemname-$pkgver.gem
  [ -d "$pkgdir$_gemdir/bin" ]  && find "$pkgdir$_gemdir/bin" -type f -exec chmod 755 '{}' ';'
  [ -d "$pkgdir$_gemdir/gems" ] && find "$pkgdir$_gemdir/gems" -name '*.o' -exec rm -f '{}' ';'
  rm -f "$pkgdir$_gemdir/cache/$_gemname-$pkgver.gem"
  find "$pkgdir$_gemdir" -depth -type d -empty -exec rmdir '{}' ';'
}
}
      spew('PKGBUILD', pkgbuild)
    end
  end

  class Installer
    include Util

    def initialize()
      @order = []
      @packages = {}
    end

    def install
      @order.reject! {|pkg| pkg.installed? }
      @order.each {|pkg| pkg.install }
    end

    def resolve(name, version)
      resolve_dep(Gem::Dependency.new(name, version), true)
    end

    private

    def resolve_dep(dep, explicit)
      @packages[dep.name] ||= begin
        info "Resolving Gem #{dep}..."
        spec, uri = Gem::SpecFetcher.fetcher.fetch(dep, true).last
        raise "Gem #{dep} not found" if !spec
        subinfo(spec.full_name)
        spec.runtime_dependencies.each {|dep| resolve_dep(dep, false) }
        Package.new(dep.name, spec.version, uri, explicit).tap {|pkg| @order << pkg }
      end
    end
  end

  def self.run(args)
    if args.length < 1
      puts "Usage: #{$0} gem-name [gem-version]"
      exit
    end

    raise 'You must not be root to run pacgem!' if Process.uid == 0

    trap :SIGINT do
      Util.error 'Aborted by user! Exiting...'
      exit
    end

    Dir.mktmpdir('pacgem-') do |tmp|
      Dir.chdir(tmp) do
        installer = Installer.new
        installer.resolve(args[0], args[1])
        installer.install
      end
    end
  rescue => ex
    Util.error ex.message
    exit 1
  end
end

PacGem.run(ARGV) if $0 == __FILE__
