#!/usr/bin/ruby

require 'tmpdir'
require 'rubygems'
require 'rubygems/format'
require 'shellwords'
require 'open-uri'
require 'digest/sha2'
require 'optparse'
require 'fileutils'

module Pacgem
  VERSION = '0.8'

  module Util
    def which?(name)
      `which #{name} 2>/dev/null`
      $?.success?
    end

    def spew(file, content)
      File.open(file, 'w') {|f| f.write(content.to_s) }
    end

    def truncate(s, max, omission = '...')
      s = s.to_s
      s.length > max ? s[0...max] + omission : s
    end
  end

  class Logger
    def initialize
      @color = STDOUT.isatty
    end

    def color?
      @color
    end

    def nocolor!
      @color = false
    end

    def msg(s)
      print('==> ', :green, :bold)
      puts(s, :bold)
    end

    def msg2(s)
      print('  -> ', :blue, :bold)
      puts(s, :bold)
    end

    def warn(s)
      print('==> WARNING: ', :yellow, :bold)
      puts(s, :bold)
    end

    def error(s)
      print('==> ERROR: ', :red, :bold)
      puts(s, :bold)
    end

    def print(s, *c)
      STDOUT.print(color(s, *c))
    end

    def puts(s, *c)
      STDOUT.puts(color(s, *c))
    end

    private

    COLORS = {
      :clear         =>  0,
      :bold          =>  1,
      :dark          =>  2,
      :italic        =>  3, # not widely implemented
      :underline     =>  4,
      :blink         =>  5,
      :rapid_blink   =>  6, # not widely implemented
      :reverse       =>  7,
      :concealed     =>  8,
      :strikethrough =>  9, # not widely implemented
      :black         => 30,
      :red           => 31,
      :green         => 32,
      :yellow        => 33,
      :blue          => 34,
      :magenta       => 35,
      :cyan          => 36,
      :white         => 37,
      :bg_black      => 40,
      :bg_red        => 41,
      :bg_green      => 42,
      :bg_yellow     => 43,
      :bg_blue       => 44,
      :bg_magenta    => 45,
      :bg_cyan       => 46,
      :bg_white      => 47,
    }

    def color(s, *c)
      if color?
        res = ''
        c.each {|c| res << "\e[#{COLORS[c]}m" }
        res << "#{s}\e[0m"
      else
        s
      end
    end
  end

  class PkgBuild
    include Util

    def initialize
      @vars = []
      @@build ||= DATA.read
    end

    def []=(key, val)
      @vars << [key, val]
    end

    def to_s
      lines = "# Generated by pacgem\n"
      @vars.each do |(key,val)|
        if Array === val
          val = val.map {|v| v.inspect }.join("\n" + (' ' * (key.size + 2)))
          lines << "#{key}=(#{val})\n"
        else
          lines << "#{key}=#{val.inspect}\n"
        end
      end
      lines + @@build
    end

    def save
      spew('PKGBUILD', self)
    end
  end

  class Package
    include Util

    attr_reader :gemname, :name, :version, :uri
    attr_writer :explicit

    def initialize(name, version, uri)
      @gemname = name
      @name = "#{Package.ruby}-#{name.downcase}"
      @version, @uri = version, uri
    end

    def explicit?
      @explicit
    end

    def installed?
      installed = `pacman -Q #{name.shellescape} 2>/dev/null`.strip.split(/\s+/, 2)
      installed[1] =~ /^#{version}\-\d+$/
    end

    def install(options, logger)
      FileUtils.mkpath(name)
      Dir.chdir(name) do
        gemfile = download
        gen_pkgbuild(gemfile, options)
        pkgfile = makepkg(options)
        namcap(pkgfile, logger)
        pacman(pkgfile, logger) unless options[:create]
      end
    end

    private

    def self.ruby
      @ruby ||= if RUBY_VERSION > '1.9'
                    'ruby'
                  elsif Gem.ruby.include?('ruby-enterprise')
                    'ruby-enterprise'
                  else
                    'ruby1.8'
                  end
    end

    def download
      gemfile = "#{gemname}-#{version}.gem"
      open("#{uri}gems/#{gemfile}") do |i|
        File.open(gemfile, 'w') do |o|
          FileUtils.copy_stream(i, o)
        end
      end
      gemfile
    end

    def gen_pkgbuild(gemfile, options)
      spec = Gem::Format.from_file_by_path(gemfile).spec

      depends = [Package.ruby]
      spec.runtime_dependencies.each do |dep|
        dep.requirement.requirements.each do |comp, ver|
          comp = '>=' if comp == '~>'
          depends << "#{Package.ruby}-#{dep.name.downcase}#{comp}#{ver}"
        end
      end

      optdepends = []
      spec.development_dependencies.each do |dep|
        optspec, opturi = Gem::SpecFetcher.fetcher.fetch(dep, true).last
        optdepends << "#{Package.ruby}-#{dep.name.downcase}: #{truncate(optspec.summary, 80)}" if optspec
      end

      builder = %w(build fix)
      unless spec.extensions.empty?
        builder << 'cleanext'
        builder << 'autodepends' unless options[:noautodepends]
      end

      pkg = PkgBuild.new
      pkg['_gemname']    = spec.name
      pkg['_gembuilder'] = builder
      pkg['_ruby']       = Gem.ruby
      pkg['_gem']        = File.join(File.dirname(Gem.ruby), 'gem')
      pkg['pkgname']     = name
      pkg['pkgver']      = spec.version.to_s
      pkg['pkgrel']      = 1
      pkg['pkgdesc']     = spec.summary
      pkg['arch']        = spec.extensions.empty? ? %w(any) : %w(i686 x86_64)
      pkg['url']         = spec.homepage
      pkg['license']     = [spec.license || 'Ruby']
      pkg['makedepends'] = %W(#{Package.ruby} binutils)
      pkg['depends']     = depends
      pkg['optdepends']  = optdepends
      pkg['source']      = %W(#{uri}gems/$_gemname-$pkgver.gem)
      pkg['sha256sums']  = [Digest::SHA2.file(gemfile).to_s]
      pkg['noextract']   = %w($_gemname-$pkgver.gem)
      pkg['options']     = %w(!emptydirs)
      pkg.save
    end

    def makepkg(options)
      system("makepkg -f #{options[:create] && '--nodeps'} #{options[:nocolor] && '--nocolor'}")
      Dir["#{name}-*.pkg.*"].first || raise("makepkg #{name} failed")
    end

    def namcap(pkgfile, logger)
      if which?('namcap')
        logger.msg "Checking #{pkgfile} with namcap..."
        system("namcap #{pkgfile}")
      else
        logger.warn 'namcap is not installed'
      end
    end

    def pacman(pkgfile, logger)
      logger.msg "Installing #{pkgfile} with pacman..."
      cmd = "pacman --as#{explicit? ? 'explicit' : 'deps'} -U #{pkgfile.shellescape}"
      if which?('sudo')
        system("sudo #{cmd}")
      else
        system("su -c #{cmd.shellescape}")
      end
    end
  end

  class Installer
    def initialize(options, logger)
      @options, @logger = options, logger
      @list = []
      @packages = {}
    end

    def install
      @list.reject! {|pkg| pkg.installed? } unless @options[:create]
      @list.each {|pkg| pkg.install(@options, @logger) }
    end

    def resolve(name, version = nil)
      pkg = resolve_dep(Gem::Dependency.new(name, version))
      pkg.explicit = true
    end

    private

    def resolve_dep(dep)
      @packages[dep.name] ||= begin
        spec, uri = Gem::SpecFetcher.fetcher.fetch(dep, true).last
        raise "Gem #{dep} not found" unless spec
        @logger.msg2 "#{spec.full_name}: #{spec.summary}"
        spec.runtime_dependencies.each {|d| resolve_dep(d) }
        pkg = Package.new(dep.name, spec.version, uri)
        @list << pkg
        pkg
      end
    end
  end

  class Command
    def initialize(args)
      @args = args
      @options = {}
      @logger = Logger.new
    end

    def run
      @opts = OptionParser.new(&method(:set_opts))
      @opts.parse!(@args)
      process
      exit 0
    rescue OptionParser::ParseError => ex
      STDERR.puts ex.message
      STDERR.puts @opts
      exit 1
    rescue Exception => ex
      raise ex if @options[:trace] || SystemExit === ex
      @logger.error ex.message
      @logger.msg2 'Use --trace for backtrace.'
      exit 1
    end

    private

    def process
      if @args.length < 1
        STDERR.puts 'You must specify at least one gem.'
        STDERR.puts @opts
        exit 1
      end

      raise 'You must not be root to run pacgem!' if Process.uid == 0

      trap :SIGINT do
        @logger.error 'Aborted by user! Exiting...'
        exit 1
      end

      if @options[:destdir]
        dir = File.expand_path(@options[:destdir])
        FileUtils.mkpath(dir)
        @logger.msg "Saving package files in #{dir}"
      else
        dir = Dir.mktmpdir('pacgem-')
      end

      begin
        Dir.chdir(dir) do
          installer = Installer.new(@options, @logger)
          @logger.msg 'Resolving gems...'
          @args.each do |gem|
            if gem =~ /^([-\w]+)((?:[<>]=?|=|~>|-)\d+(?:\.\d+)*)?$/
              name, version = $1, $2
              installer.resolve(name, version =~ /^-/ ? version[1..-1] : version)
            else
              installer.resolve(gem)
            end
          end
          installer.install
        end
      ensure
        FileUtils.remove_entry_secure(dir) unless @options[:destdir]
      end
    end

    def set_opts(opts)
      opts.banner = 'Usage: pacgem [options] gems...'

      opts.separator %q{
Pacgem installs Ruby Gems using the Arch Linux Package Manager (pacman).

Examples:
    pacgem --create rake       Create ruby-rake package in the directory ./ruby-rake
    pacgem rake-1.0            Create temporary ruby-rake package and install it
    pacgem 'rake>1.0'          Different version specification
    pacgem thin 'rake~>1.0'    Different version specification

Options:
}

      opts.on('-d DIR', '--destdir DIR', String, 'Destination directory for package files') do |dir|
        @options[:destdir] = dir
      end

      opts.on('-c', '--create', :NONE, 'Create package only, do not install') do
        @options[:create] = true
        @options[:destdir] = Dir.pwd
      end

      opts.on('--noautodepends', :NONE, 'Disable automatic dependency generation for shared objects (*.so)') do
        @options[:noautodepends] = true
      end

      opts.on('--nocolor', :NONE, 'Disable colored output') do
        @logger.nocolor!
      end

      opts.on('--trace', :NONE, 'Show a full traceback on error') do
        @options[:trace] = true
      end

      opts.on_tail('-h', '--help', 'Display help and exit') do
        puts opts
        exit
      end

      opts.on_tail('-V', '--version', 'Display version and exit') do
        puts %{Pacgem Version #{VERSION}
(C) 2011 Daniel Mendler

This program may be freely redistributed under
the terms of the GNU General Public License.}
        exit
      end
    end
  end
end

Pacgem::Command.new(ARGV).run if $0 == __FILE__

__END__

_gem_build() {
  msg 'Installing gem...'

  # Install the gem
  install -d -m755 $_bindir $_gemdir
  $_gem install --no-ri --no-rdoc --ignore-dependencies \
                --bindir $_bindir --install-dir $_gemdir "$srcdir/$_gemname-$pkgver.gem"
}

_gem_fix() {
  msg 'Fixing gem installation...'

  # Set mode of executables to 755
  [ -d "$_gemdir/bin" ] && find "$_gemdir/bin" -type f -exec chmod 755 -- '{}' ';'

  # Find man pages and move them to the correct directory
  local mandir="$_gemdir/gems/$_gemname-$pkgver/man"
  if [ -d "$mandir" ]; then
    install -d -m755 $_mandir
    mv $mandir/* $_mandir
  fi

  # Remove cached gem file
  rm -f "$_gemdir/cache/$_gemname-$pkgver.gem"

  # Sometimes there are files which are not world readable. Fix this.
  find $pkgdir -type f '!' -perm '-004' -exec chmod o+r -- '{}' ';'
}

_gem_cleanext() {
  msg 'Removing native build leftovers...'
  local extdir="$_gemdir/gems/$_gemname-$pkgver/ext"
  [ -d "$extdir" ] && find "$extdir" -name '*.o' -exec rm -f -- '{}' ';'
}

# Check if dependency is already satisfied
_dependency_satisfied() {
  local dep=$1 deps="${depends[@]}"
  [ "$(type -t in_array)" == "function" ] || error "in_array should be provided by makepkg"
  while true; do
    in_array $dep ${deps[@]} && return 0
    local found=0 pkg
    # Warning: This could break easily if the pacman output format changes.
    for pkg in $(LC_ALL=C pacman -Qi ${deps[@]} 2>/dev/null | sed '/Depends On/!d;s/.*: //;s/None\|[<>]=\?[^ ]*\|=[^ ]*//g'); do
      if ! in_array $pkg ${deps[@]}; then
        deps=(${deps[@]} $pkg) && found=1
      fi
    done
    [ $found -eq 1 ] || break
  done
  return 1
}

_gem_autodepends() {
  msg 'Automatic dependency resolution...'

  # Find all referenced shared libraries
  local deps=$(find $pkgdir -type f -name '*.so')
  [ "$deps" != '' ] || return 0

  deps=$(readelf -d $deps | sed '/library:/!d;s/.*library: \[\(.*\)\].*/\1/' | sort | uniq)

  # Find referenced libraries on the library search path
  local libs=() lib path
  for lib in $deps; do
    for path in /lib /usr/lib; do
      [ -f "$path/$lib" ] && libs=(${libs[@]} "$path/$lib")
    done
  done
  [ "${#libs}" -ne 0 ] || return 0

  msg2 "Referenced libraries: ${libs[*]}"

  # Find matching packages with pacman -Qo
  # and add them to the depends array
  local pkg
  for pkg in $(pacman -Qqo ${libs[@]}); do
    _dependency_satisfied $pkg || depends=(${depends[@]} $pkg)
  done
  msg2 "Referenced packages: ${depends[*]}"
}

_rbconfig() {
  $_ruby -e "require 'rbconfig'; puts RbConfig::CONFIG['$1']"
}

build() {
  # Directories defined inside build() because if ruby is not installed on the system
  # makepkg will barf when sourcing the PKGBUILD
  _gemdir=$pkgdir$($_gem environment gemdir)
  _bindir=$pkgdir$(_rbconfig bindir)
  _mandir=$pkgdir$(_rbconfig mandir)

  local i
  for i in ${_gembuilder[@]}; do
    _gem_$i
  done
}
